<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>我们要讨论的浏览器</title>
    <meta name="generator" content="VuePress 1.5.2">
    
    <meta name="description" content="不定期更新">
    <link rel="preload" href="/blog/assets/css/0.styles.b89722a2.css" as="style"><link rel="preload" href="/blog/assets/js/app.cbfe7c8a.js" as="script"><link rel="preload" href="/blog/assets/js/2.ceb96644.js" as="script"><link rel="preload" href="/blog/assets/js/11.07098245.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.cbf0dac3.js"><link rel="prefetch" href="/blog/assets/js/12.d6273dbb.js"><link rel="prefetch" href="/blog/assets/js/13.7943b60b.js"><link rel="prefetch" href="/blog/assets/js/14.0ab742b1.js"><link rel="prefetch" href="/blog/assets/js/3.8099ba9f.js"><link rel="prefetch" href="/blog/assets/js/4.7d5f245c.js"><link rel="prefetch" href="/blog/assets/js/5.a3b3e033.js"><link rel="prefetch" href="/blog/assets/js/6.9a636937.js"><link rel="prefetch" href="/blog/assets/js/7.2c1cfb48.js"><link rel="prefetch" href="/blog/assets/js/8.d54f5dc6.js"><link rel="prefetch" href="/blog/assets/js/9.30ff685e.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.b89722a2.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/imgs/logo.png" alt="" class="logo"> <!----></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>原理类</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/ta/destructuring.html" class="sidebar-link">变量的解构赋值详解</a></li><li><a href="/blog/ta/promise.html" class="sidebar-link">Promise</a></li><li><a href="/blog/ta/router.html" class="sidebar-link">路由及实现原理</a></li><li><a href="/blog/ta/browser.html" aria-current="page" class="active sidebar-link">浏览器工作原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/ta/browser.html#我们要讨论的浏览器" class="sidebar-link">我们要讨论的浏览器</a></li><li class="sidebar-sub-header"><a href="/blog/ta/browser.html#浏览器的主要功能" class="sidebar-link">浏览器的主要功能</a></li><li class="sidebar-sub-header"><a href="/blog/ta/browser.html#浏览器的高层结构" class="sidebar-link">浏览器的高层结构</a></li><li class="sidebar-sub-header"><a href="/blog/ta/browser.html#浏览器的多进程架构" class="sidebar-link">浏览器的多进程架构</a></li><li class="sidebar-sub-header"><a href="/blog/ta/browser.html#浏览器的架构" class="sidebar-link">浏览器的架构</a></li><li class="sidebar-sub-header"><a href="/blog/ta/browser.html#导航过程发生了什么" class="sidebar-link">导航过程发生了什么</a></li><li class="sidebar-sub-header"><a href="/blog/ta/browser.html#渲染进程是如何工作的" class="sidebar-link">渲染进程是如何工作的</a></li><li class="sidebar-sub-header"><a href="/blog/ta/browser.html#浏览器对事件的处理" class="sidebar-link">浏览器对事件的处理</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>实战篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>记事本</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="我们要讨论的浏览器"><a href="#我们要讨论的浏览器" class="header-anchor">#</a> 我们要讨论的浏览器</h2> <p>目前使用的主流浏览器有五个：Internet Explorer、Firefox、Safari、Chrome 浏览器和 Opera。本文中以开放源代码浏览器Chrome为例。</p> <h2 id="浏览器的主要功能"><a href="#浏览器的主要功能" class="header-anchor">#</a> 浏览器的主要功能</h2> <p>浏览器的主要功能就是向服务器发出请求，在浏览器窗口中展示您选择的网络资源。这里所说的资源一般是指 HTML 文档，也可以是 PDF、图片或其他的类型。资源的位置由用户使用 URI（统一资源标示符）指定。</p> <div class="language- extra-class"><pre class="language-text"><code>URI就是在某一规则下能把一个资源独一无二地标识出来。
URL（统一资源定位符）是URI的一种，代表资源在网络上的唯一地址，是URI命名机制的一个子集
例如：
协议://地球/中国/浙江省/杭州市/西湖区/某大学/14号宿舍楼/525号寝/张三.
这个字符串同样标识出了唯一的一个人，起到了URI的作用，所以URL是URI的子集。URL是以描述人的位置来唯一确定一个人的。用身份证号也可以唯一确定一个人。我们也可以用：身份证号：123456789
</code></pre></div><h2 id="浏览器的高层结构"><a href="#浏览器的高层结构" class="header-anchor">#</a> 浏览器的高层结构</h2> <p>浏览器的主要组件为：</p> <ul><li>用户界面
<ul><li>包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。</li></ul></li> <li>浏览器引擎
<ul><li>在用户界面和呈现引擎之间传送指令。</li></ul></li> <li>呈现引擎
<ul><li>负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。</li></ul></li> <li>网络
<ul><li>用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。</li></ul></li> <li>用户界面后端
<ul><li>用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。</li></ul></li> <li>JavaScript 解释器
<ul><li>用于解析和执行 JavaScript 代码。</li></ul></li> <li>数据存储
<ul><li>浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。</li></ul></li></ul> <p><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#The_browser_high_level_structure" target="_blank" rel="noopener noreferrer">浏览器的工作原理：新式网络浏览器幕后揭秘<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="浏览器的多进程架构"><a href="#浏览器的多进程架构" class="header-anchor">#</a> 浏览器的多进程架构</h2> <p>一个好的程序常常被划分为几个相互独立又彼此配合的模块,浏览器也是如此,他由多个进程组成,每个进程都有自己的核心职责,它们互相配合完成浏览器的整体功能,每个进程又包含多个线程,一个进程内的多个线程会协同工作,配合完成所在进程的职责.</p> <p><strong>进程(process)和线程(thread)</strong></p> <p>当我们启动一个应用，计算机会创建一个进程，操作系统会为进程分配一部分内存，应用的所有状态都会保存在这块内存中，应用也许还会创建多个线程来辅助工作(进程内多个线程)，这些线程可以共享这部分内存中的数据。如果应用关闭，进程会被终结，操作系统会释放相关内存。</p> <p>一个进程还可以要求操作系统生成另一个进程来执行不同的任务，系统会为新的进程分配独立的内存，两个进程之间可以使用 IPC （Inter Process Communication）进行通信。很多应用都会采用这样的设计，如果一个工作进程反应迟钝，重启这个进程不会影响应用其它进程的工作。</p> <h2 id="浏览器的架构"><a href="#浏览器的架构" class="header-anchor">#</a> 浏览器的架构</h2> <p>一个浏览器，它可以是单进程多线程的应用，也可以是使用 IPC 通信的多进程应用。
不同浏览器采用了不同的架构模式，这里并不存在标准，本文以 Chrome 为例进行说明:
Chrome 采用多进程架构，其顶层存在一个 Browser process 用以协调浏览器的其它进程。
具体说来，Chrome 的主要进程及其职责如下：</p> <ul><li>Browser Process：
<ul><li>负责包括地址栏，书签栏，前进后退按钮等部分的工作；</li> <li>负责处理浏览器的一些不可见的底层操作，比如网络请求和文件访问；</li></ul></li> <li>Renderer Process：
<ul><li>负责一个标签页内关于网页呈现的所有事情</li></ul></li> <li>Plugin Process：
<ul><li>负责控制一个网页用到的所有插件，如 flash</li></ul></li> <li>GPU Process
<ul><li>负责处理 GPU 相关的任务</li></ul></li></ul> <p>Chrome 还为我们提供了「任务管理器」，供我们方便的查看当前浏览器中运行的所有进程及每个进程占用的系统资源，右键单击还可以查看更多类别信息。</p> <p>通过「页面右上角的三个点 --- 更多工具 --- 任务管理器」即可打开相关面板</p> <h2 id="导航过程发生了什么"><a href="#导航过程发生了什么" class="header-anchor">#</a> 导航过程发生了什么</h2> <p>我们知道负责处理浏览器的一些不可见的底层操作，是由 Browser Process 进程掌控,Browser Process 又对这些工作进一步划分,使用不同线程进行处理.</p> <ul><li>UI thread ： 控制浏览器上的按钮及输入框；</li> <li>network thread: 处理网络请求，从网上获取数据；</li> <li>storage thread: 控制文件等的访问；</li></ul> <p>当我们在浏览器地址栏中输入文字，并点击回车获得页面内容的过程在浏览器看来可以分为以下几步：</p> <p><strong>1. 处理输入</strong></p> <p>UI thread 需要判断用户输入的是 URL 还是 query；</p> <p><strong>2. 开始导航</strong></p> <p>当用户点击回车键，UI thread 通知 network thread 获取网页内容，并控制 tab 上的 spinner 展现，表示正在加载中。</p> <p>network thread 会执行 DNS 查询，随后为请求建立 TLS 连接</p> <p>如果 network thread 接收到了重定向请求头如 301，network thread 会通知 UI thread 服务器要求重定向，之后，另外一个 URL 请求会被触发。</p> <p><strong>3. 读取响应</strong></p> <p>当请求响应返回的时候，network thread 会依据 Content-Type 及 MIME Type sniffing 判断响应内容的格式</p> <div class="language- extra-class"><pre class="language-text"><code>Response Headers
Content-Length: 0
Content-Type: text/html; charset=utf-8
...
</code></pre></div><p>如果响应内容的格式是 HTML ，下一步将会把这些数据传递给 renderer process，如果是 zip 文件或者其它文件，会把相关数据传输给下载管理器。</p> <p>Safe Browsing 检查也会在此时触发，如果域名或者请求内容匹配到已知的恶意站点，network thread 会展示一个警告页。此外 CORB 检测也会触发确保敏感数据不会被传递给渲染进程。</p> <p><strong>4. 查找渲染进程</strong></p> <p>当上述所有检查完成，network thread 确信浏览器可以导航到请求网页，network thread 会通知 UI thread 数据已经准备好，UI thread 会查找到一个 renderer process 进行网页的渲染。</p> <p>由于网络请求获取响应需要时间，这里其实还存在着一个加速方案。当 UI thread 发送 URL 请求给 network thread 时，浏览器其实已经知道了将要导航到那个站点。UI thread 会并行的预先查找和启动一个渲染进程，如果一切正常，当 network thread 接收到数据时，渲染进程已经准备就绪了，但是如果遇到重定向，准备好的渲染进程也许就不可用了，这时候就需要重启一个新的渲染进程。</p> <p><strong>5. 确认导航</strong></p> <p>进过了上述过程，数据以及渲染进程都可用了， Browser Process 会给 renderer process 发送 IPC 消息来确认导航，一旦 Browser Process 收到 renderer process 的渲染确认消息，导航过程结束，页面加载过程开始。</p> <p>此时，地址栏会更新，展示出新页面的网页信息。history tab 会更新，可通过返回键返回导航来的页面，为了让关闭 tab 或者窗口后便于恢复，这些信息会存放在硬盘中</p> <p><strong>6. 额外的步骤</strong></p> <p>一旦导航被确认，renderer process 会使用相关的资源渲染页面，下文中我们将重点介绍渲染流程。当 renderer process 渲染结束（渲染结束意味着该页面内的所有的页面，包括所有 iframe 都触发了 onload 时），会发送 IPC 信号到 Browser process， UI thread 会停止展示 tab 中的 spinner。</p> <p>当然上面的流程只是网页首帧渲染完成，在此之后，客户端依旧可下载额外的资源渲染出新的视图。</p> <p>在这里我们可以明确一点，所有的 JS 代码其实都由 renderer Process 控制的，所以在你浏览网页内容的过程大部分时候不会涉及到其它的进程。不过也许你也曾经监听过 beforeunload 事件，这个事件再次涉及到 Browser Process 和 renderer Process 的交互，当当前页面关闭时（关闭 Tab ，刷新等等），Browser Process 需要通知 renderer Process 进行相关的检查，对相关事件进行处理。</p> <p>如果导航由 renderer process 触发（比如在用户点击某链接，或者 JS 执行 <code>window.location = &quot;http://newsite.com&quot;</code> ） renderer process 会首先检查是否有 <code>beforeunload</code> 事件处理器，导航请求由 renderer process 传递给 Browser process</p> <p>如果导航到新的网站，会启用一个新的 render process 来处理新页面的渲染，老的进程会留下来处理类似 <code>unload</code> 等事件。</p> <p>除了上述流程，有些页面还拥有 Service Worker （服务工作线程），Service Worker 让开发者对本地缓存及判断何时从网络上获取信息有了更多的控制权，如果 Service Worker 被设置为从本地 cache 中加载数据，那么就没有必要从网上获取更多数据了。</p> <p>值得注意的是 service worker 也是运行在渲染进程中的 JS 代码，因此对于拥有 Service Worker 的页面，上述流程有些许的不同。</p> <p>当有 Service Worker 被注册时，其作用域会被保存，当有导航时，network thread 会在注册过的 Service Worker 的作用域中检查相关域名，如果存在对应的 Service worker，UI thread 会找到一个 renderer process 来处理相关代码，Service Worker 可能会从 cache 中加载数据，从而终止对网络的请求，也可能从网上请求新的数据。</p> <p>如果 Service Worker 最终决定通过网上获取数据，Browser 进程 和 renderer 进程的交互其实会延后数据的请求时间 。Navigation Preload 是一种与 Service Worker 并行的加速加载资源的机制，服务端通过请求头可以识别这类请求，而做出相应的处理。</p> <h2 id="渲染进程是如何工作的"><a href="#渲染进程是如何工作的" class="header-anchor">#</a> 渲染进程是如何工作的</h2> <p>渲染进程几乎负责 Tab 内的所有事情，渲染进程的核心目的在于转换 HTML CSS JS 为用户可交互的 web 页面。渲染进程中主要包含以下线程：</p> <ul><li>主线程 Main thread</li> <li>工作线程 Worker thread</li> <li>排版线程 Compositor thread</li> <li>光栅线程 Raster thread</li></ul> <h3 id="渲染的流程"><a href="#渲染的流程" class="header-anchor">#</a> 渲染的流程</h3> <p><strong>1. 构建 DOM</strong></p> <p>当渲染进程接收到导航的确认信息，开始接受 HTML 数据时，主线程会解析文本字符串为 DOM。</p> <p>渲染 html 为 DOM 的方法由 HTML Standard 定义。</p> <p><strong>2. 加载次级的资源</strong></p> <p>网页中常常包含诸如图片，CSS，JS 等额外的资源，这些资源需要从网络上或者 cache 中获取。主进程可以在构建 DOM 的过程中会逐一请求它们，为了加速 preload scanner 会同时运行，如果在 html 中存在 <code>&lt;img&gt;</code> <code>&lt;link&gt;</code> 等标签，preload scanner 会把这些请求传递给 Browser process 中的 network thread 进行相关资源的下载。</p> <p><strong>3. JS 的下载与执行</strong></p> <p>当遇到 <code>&lt;script&gt;</code> 标签时，渲染进程会停止解析 HTML，而去加载，解析和执行 JS 代码，停止解析 html 的原因在于 JS 可能会改变 DOM 的结构（使用诸如 <code>document.write()</code>等API）。</p> <p>不过开发者其实也有多种方式来告知浏览器应对如何应对某个资源，比如说如果在<code>&lt;script&gt;</code> 标签上添加了 <code>async</code> 或 <code>defer</code> 等属性，浏览器会异步的加载和执行JS代码，而不会阻塞渲染。</p> <p><strong>4. 样式计算</strong></p> <p>仅仅渲染 DOM 还不足以获知页面的具体样式，主进程还会基于 CSS 选择器解析 CSS 获取每一个节点的最终的计算样式值。即使不提供任何 CSS，浏览器对每个元素也会有一个默认的样式。</p> <p><strong>5. 获取布局</strong></p> <p>想要渲染一个完整的页面，除了获知每个节点的具体样式，还需要获知每一个节点在页面上的位置，布局其实是找到所有元素的几何关系的过程。其具体过程如下：</p> <p>通过遍历 DOM 及相关元素的计算样式，主线程会构建出包含每个元素的坐标信息及盒子大小的布局树。布局树和 DOM 树类似，但是其中只包含页面可见的元素，如果一个元素设置了 <code>display:none</code> ，这个元素不会出现在布局树上，伪元素虽然在 DOM 树上不可见，但是在布局树上是可见的。</p> <p><strong>6. 绘制各元素</strong></p> <p>即使知道了不同元素的位置及样式信息，我们还需要知道不同元素的绘制先后顺序才能正确绘制出整个页面。在绘制阶段，主线程会遍历布局树以创建绘制记录。绘制记录可以看做是记录各元素绘制先后顺序的笔记。</p> <p><strong>7. 合成帧</strong></p> <p>主线程会遍历布局树来创建层树（layer tree），一旦层树被创建，渲染顺序被确定，主线程会把这些信息通知给合成器线程，合成器线程会栅格化每一层。有的层的可以达到整个页面的大小，因此，合成器线程将它们分成多个磁贴，并将每个磁贴发送到栅格线程，栅格线程会栅格化每一个磁贴并存储在 GPU 显存中。</p> <p>一旦磁贴被光栅化，合成器线程会收集称为绘制四边形的磁贴信息以创建合成帧。</p> <p>合成帧随后会通过 IPC 消息传递给浏览器进程，由于浏览器的 UI 改变或者其它拓展的渲染进程也可以添加合成帧，这些合成帧会被传递给 GPU 用以展示在屏幕上，如果滚动发生，合成器线程会创建另一个合成帧发送给 GPU。</p> <p>合成器的优点在于，其工作无关主线程，合成器线程不需要等待样式计算或者 JS 执行，这就是为什么合成器相关的动画 最流畅，如果某个动画涉及到布局或者绘制的调整，就会涉及到主线程的重新计算，自然会慢很多。</p> <h2 id="浏览器对事件的处理"><a href="#浏览器对事件的处理" class="header-anchor">#</a> 浏览器对事件的处理</h2> <p>浏览器通过对不同事件的处理来满足各种交互需求，这一部分我们一起看看从浏览器的视角，事件是什么，在此我们先主要考虑鼠标事件。</p> <blockquote><p>在浏览器看来，用户的所有手势都是输入，鼠标滚动，悬置，点击等等都是。</p></blockquote> <p>当用户在屏幕上触发诸如 touch 等手势时，首先收到手势信息的是 Browser process， 不过 Browser process 只会感知到在哪里发生了手势，对 tab 内内容的处理是还是由渲染进程控制的。</p> <p>事件发生时，浏览器进程会发送事件类型及相应的坐标给渲染进程，渲染进程随后找到事件对象并执行所有绑定在其上的相关事件处理函数。</p> <p>前文中，我们提到过合成器可以独立于主线程之外通过合成栅格化层平滑的处理滚动。如果页面中没有绑定相关事件，组合器线程可以独立于主线程创建组合帧。如果页面绑定了相关事件处理器，主线程就不得不出来工作了。这时候合成器线程会怎么处理呢？</p> <p>这里涉及到一个专业名词「理解非快速滚动区域（non-fast scrollable region）」由于执行 JS 是主线程的工作，当页面合成时，合成器线程会标记页面中绑定有事件处理器的区域为 non-fast scrollable region ，如果存在这个标注，合成器线程会把发生在此处的事件发送给主线程，如果事件不是发生在这些区域，合成器线程则会直接合成新的帧而不用等到主线程的响应。</p> <p>web 开发中常用的事件处理模式是事件委托，基于事件冒泡，我们常常在最顶层绑定事件：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'touchstart'</span><span class="token punctuation">,</span> 
<span class="token parameter">event</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span>target <span class="token operator">===</span> area<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        event<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>上述做法很常见，但是如果从浏览器的角度看，整个页面都成了 non-fast scrollable region 了。</p> <p>这意味着即使操作的是页面无绑定事件处理器的区域，每次输入时，合成器线程也需要和主线程通信并等待反馈，流畅的合成器独立处理合成帧的模式就失效了。</p> <p>为了防止这种情况，我们可以为事件处理器传递 <code>passive: true</code> 做为参数，这样写就能让浏览器即监听相关事件，又让组合器线程在等等主线程响应前构建新的组合帧。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'touchstart'</span><span class="token punctuation">,</span> <span class="token parameter">event</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span>target <span class="token operator">===</span> area<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        event<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>passive<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>不过上述写法可能又会带来另外一个问题，假设某个区域你只想要水平滚动，使用 <code>passive: true</code> 可以实现平滑滚动，但是垂直方向的滚动可能会先于<code>event.preventDefault()</code>发生，此时可以通过 <code>event.cancelable</code> 来防止这种情况。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'pointermove'</span><span class="token punctuation">,</span> <span class="token parameter">event</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span>cancelable<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        event<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// block the native scroll</span>
        <span class="token comment">/*
        *  do what you want the application to do here
        */</span>
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>passive<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>也可以使用css属性 <code>touch-action</code> 来完全消除事件处理器的影响，如：</p> <div class="language-csss extra-class"><pre class="language-text"><code>#area { 
  touch-action: pan-x; 
}
</code></pre></div><p><strong>查找到事件对象</strong></p> <p>当组合器线程发送输入事件给主线程时，主线程首先会进行命中测试（hit test）来查找对应的事件目标，命中测试会基于渲染过程中生成的绘制记录（ paint records ）查找事件发生坐标下存在的元素。</p> <p><strong>事件的优化</strong></p> <p>一般我们屏幕的刷新速率为 60fps，但是某些事件的触发量会不止这个值，出于优化的目的，Chrome 会合并连续的事件(如 wheel, mousewheel, mousemove, pointermove, touchmove )，并延迟到下一帧渲染时候执行 。</p> <p>而如 keydown, keyup, mouseup, mousedown, touchstart, 和 touchend 等非连续性事件则会立即被触发</p> <p>合并事件虽然能提示性能，但是如果你的应用是绘画等，则很难绘制一条平滑的曲线了，此时可以使用 <code>getCoalescedEvents</code> API 来获取组合的事件。示例代码如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'pointermove'</span><span class="token punctuation">,</span> <span class="token parameter">event</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> events <span class="token operator">=</span> event<span class="token punctuation">.</span><span class="token function">getCoalescedEvents</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> event <span class="token keyword">of</span> events<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> x <span class="token operator">=</span> event<span class="token punctuation">.</span>pageX<span class="token punctuation">;</span>
        <span class="token keyword">const</span> y <span class="token operator">=</span> event<span class="token punctuation">.</span>pageY<span class="token punctuation">;</span>
        <span class="token comment">// draw a line using x and y coordinates.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><a href="https://zhuanlan.zhihu.com/p/47407398" target="_blank" rel="noopener noreferrer">原文:图解浏览器的基本工作原理<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>相关文章推荐：</p> <p><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#The_browser_high_level_structure" target="_blank" rel="noopener noreferrer">浏览器的工作原理：新式网络浏览器幕后揭秘<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://www.jianshu.com/p/d616d887953a" target="_blank" rel="noopener noreferrer">浏览器工作原理：从 URL 输入到页面展现到底发生了什么？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://kb.cnblogs.com/page/132716/" target="_blank" rel="noopener noreferrer">技术普及帖：你刚才在淘宝上买了一件东西<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/ta/router.html" class="prev">
        路由及实现原理
      </a></span> <span class="next"><a href="/blog/sz/lazy.html">
        图片懒加载
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.cbfe7c8a.js" defer></script><script src="/blog/assets/js/2.ceb96644.js" defer></script><script src="/blog/assets/js/11.07098245.js" defer></script>
  </body>
</html>
